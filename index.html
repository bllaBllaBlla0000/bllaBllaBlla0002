<!doctype html>
<html lang="sq">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Quiz - HTML/CSS/JS</title>
  <style>
    :root{
      font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif;
      color-scheme: light dark; /* lejon dark/light auto */
    }

    /* --- LIGHT MODE (default) --- */
    body{
      margin:0;
      font-size:17px;
      background:#ffffff;
      color:#000000;
    }
    .container{max-width:1200px;margin:36px auto;padding:28px;}
    header{display:flex;align-items:center;justify-content:space-between;gap:18px;margin-bottom:18px}
    h1{font-size:24px;margin:0}
    .small{font-size:14px;}

    .layout{display:grid;grid-template-columns:320px 1fr;gap:26px}
    .sidebar{padding-right:14px}

    .qbtn{display:block;width:100%;text-align:left;padding:12px;border-radius:10px;border:1px solid #ccc;background:#f3f3f3;margin-bottom:10px;cursor:pointer;font-size:17px;color:#000}
    .qbtn.active{background:#e2e2e2}

    .card{padding:18px;border:1px solid #ccc;border-radius:12px;background:#ffffff;color:#000}
    .question{font-weight:600;margin-bottom:14px;font-size:20px}

    .options{display:flex;flex-direction:column;gap:12px}
    label.option{display:flex;align-items:center;gap:14px;padding:12px;border-radius:10px;border:1px solid #ccc;cursor:pointer;background:#fafafa;font-size:17px;color:#000}
    label.option:hover{background:#f0f0f0}
    label.option input{transform:scale(1.25)}

    .controls{display:flex;gap:12px;align-items:center;margin-top:18px}
    button{padding:10px 16px;border-radius:8px;border:1px solid #aaa;cursor:pointer;font-size:17px;background:#eaeaea;color:#000}
    .status{margin-left:auto;font-size:14px;}

    .hint{margin-top:10px;font-size:14px;color:#b33}


    /* --- DARK MODE AUTOMATIC (system preferred) --- */
    @media (prefers-color-scheme: dark){
      body{background:#0d0f11;color:#ddd}

      .qbtn{background:#1b1d20;border-color:#333;color:#ddd}
      .qbtn.active{background:#2a2d31}

      .card{background:#1a1d21;border-color:#333;color:#ddd}

      label.option{background:#1a1d21;border-color:#444;color:#ddd}
      label.option:hover{background:#24272c}

      button{background:#2a2d31;border-color:#555;color:#ddd}
    }


    /* --- RESPONSIVE --- */
    @media (max-width:720px){
      .layout{grid-template-columns:1fr;}
      #questionList{display:flex;gap:8px;overflow:auto;padding-bottom:6px}
      .controls{flex-direction:column;align-items:stretch}
      button{width:100%}
      .controls button + button{margin-top:8px}
    }
  </style>
</head>
<body>
  <!-- JS remains unchanged, paste your script here -->
  <div class="container">
    <header>
      <h1>Quiz (HTML/CSS/JS) — Zgjidh pyetjet</h1>
      <div class="small">Në çdo pyetje: zgjidh të gjitha opsionet e sakta.</div>
    </header>
    <div class="layout">
      <aside class="sidebar card">
        <div style="font-weight:600;margin-bottom:8px;color:var(--text)">Pyetjet</div>
        <div id="questionList"></div>
        <div class="small">Progres: <span id="progress">0/0</span></div>
      </aside>

      <main class="card">
        <div id="quizArea">
          <div class="question" id="questionText">Zgjidh një pyetje nga lista majtas.</div>
          <div class="options" id="options"></div>

          <div class="controls">
            <button id="prevBtn" class="btn-muted">Prev</button>
            <button id="nextBtn" class="btn-primary">Next</button>
            <button id="showBtn" class="btn-muted">Show answers</button>
            <div class="status" id="statusText">Not answered</div>
          </div>

          <div class="hint" id="hint"></div>
        </div>
      </main>
    </div>
  </div>

    <script>
        // --- QUESTIONS: you can replace/extend this array ---
        const questions = [
            {
                question: "Metoda per te marre nje celes me vlere ne trie eshte:",
                options: [
                    "Node get (Node x, String key, Value val, int d);",
                    "Node get(String key, int value);",
                    "Node get (int id, String key, Value val);",
                    "Node get (Node x, String key, int d);",
                ],
                correct: [3],
            },
            {
                question: "Per te ndertuar nje aplikacion I cili posedon funksionin autocomplete preferohet te perdoret:",
                options: [
                    "Brute Force",
                    "R-Way Tries",
                    "Rabin - Karp",
                    "Non-Deterministic Finite Automation",
                ],
                correct: [1],
            },
            {
                question: "Per te gjetur Shortest-Path me ane te Bellman Ford algoritmit duhet te mos kete:",
                options: ["Cikel negative", "Peshe negative", "Relaksim te segmenteve", "Vetem nje kalim (pass) neper kulme"],
                correct: [0],
            },
            {
                question: "Algoritmet te cilat aplikohen per te bere Substring search jane:",
                options: ["Boyer Moore", "Brute Force", "Key Logger", "MD5 Hash"],
                correct: [0, 1],
            },
            {
                question: "Kompleksiteti kohor i LSD varet nga:",
                options: ["Radix", "Gjatesia e stringut", "Prefix i perbashket", "Pattern"],
                correct: [0, 1],
            },
            {
                question: "Cilat nga opsionet e meposhtme paraqesin anomali te nje undirected graph:",
                options: ["DFS", "Self-loop", "Parallel-edges", "Connected components"],
                correct: [1, 2],
            },
            {
                question: "Disa prej aplikimeve te Reachability (arritshmerise) tek digrafet jane:",
                options: ["Program control-flow", "Mark-Sweep Garbage Collector", "Directed cycle detection", "Maximum Flow"],
                correct: [0, 1, 2],
            },
            {
                question: "Metodat kryesore qe perdoren per Binary standard output jane:",
                options: ["void write(boolean b)", "void write(char c);", "void write (char c, int r);", "void write(Node x, String key, Value val, int d);"],
                correct: [0, 1],
            },
            {
                question: "Grafi mund te paraqitet permes:",
                options: ["Matrices", "Adjacency Lists", "Heap", "List of edges"],
                correct: [0, 1, 3],
            },
            {
                question: "Operacionet te strings jane:",
                options: ["Index", "Concatenation", "Wildcard", "Length"],
                correct: [0, 1, 2, 3],
            },
            {
                question: "Algoritme per te gjetur MST jane:",
                options: ["Greedy", "Topological Order", "Kosaraju Sharir", "Prim Algorithm"],
                correct: [0, 3],
            },
            {
                question: "Data compression behet per shkak te:",
                options: ["Kursyer kohen e transferimit", "Decoding", "Encoding", "Perseritje te dhenave (reduction)"],
                correct: [0, 3],
            },
            {
                question: "Operacionet qe perdoren per regex jane:",
                options: ["More than once", "Exactly k", "Substring class", "Capitalised class", "At least once"],
                correct: [0, 1, 4],
            },
            {
                question: "Per te ndertuar nje aplikacion i cili ben autorizimin e personit me fingerprint preferohet:",
                options: ["Deterministic Finite Automation", "Boyer Moore", "Rabin - Karp", "Non-Deterministic Finite Automation"],
                correct: [0],
            },
            {
                question: "Teknikat per kerkim per pattern te shumefishte jane:",
                options: ["Regular expressions", "Lazy algorithm", "Rabin - Karp", "Boyer Moore"],
                correct: [0, 2, 3],
            },
            {
                question: "Metoda qe kthen nje rruge te shkurter nga kulmi i burimit eshte:",
                options: ["distTo (int v, int w)", "iterable <Directed Edge> pathTo (int v)", "distTo (int v)", "pathTo (int v)"],
                correct: [3],
            },
            {
                question: "Cilat jane ngjashmerite ne mes algoritmeve LZW dhe Huffman?",
                options: ["Implementohen me ane te Tries", "Dekodimi fillon qysh ne start te pranimit te te dhenave", "Perdoren per real-time streaming data", "Jane algoritme adaptive"],
                correct: [3],
            },
            {
                question: "Metoda qe kthen shumen e peshave ne nje MST eshte:",
                options: ["Check (edge weighted Graph)", "Weight ()", "Edges()", "Weight (digraph G)"],
                correct: [1],
            },
            {
                question: "SPT i realizuar me Bellman-Ford paraqitet me ane:",
                options: ["Add Edge() dhe weight()", "distTo[] dhe edgeTo[]", "pathTo[] dhe distTo[]", "distTo[int v] dhe edgeTo[int w]"],
                correct: [1],
            },
            {
                question: "Cila prej opsioneve nuk jane arsye per te bere kompresim te te dhenave?",
                options: ["Dekodimi i te dhenave", "Koha e transmetimit te te dhenave", "Kerkimi i te dhenave", "Perseritja e te dhenave"],
                correct: [0, 2],
            },
            {
                question: "Rruga eshte sekuence kulmesh te lidhura me ane te segmenteve.",
                options: ["PO", "JO"],
                correct: [0],
            },
            {
                question: "Nje spanning tree duhet te jete ciklik.",
                options: ["PO", "JO"],
                correct: [1],
            },
            {
                question: "Las Vegas version tek Rabin Karp algoritmi perfundon kur ka false collision.",
                options: ["PO", "JO"],
                correct: [0],
            },
            {
                question: "Cikli i Eulerit pershkron secilin segment saktesisht nje here.",
                options: ["PO", "JO"],
                correct: [0],
            },
            {
                question: "E-Transicionet tek NFA ruhen ne nje digraph.",
                options: ["PO", "JO"],
                correct: [0],
            },
            {
                question: "Algoritmi Dijkstra ne rastin me te keq ka kompleksitet kohor E log V.",
                options: ["PO", "JO"],
                correct: [0],
            },
            {
                question: "Algoritmi i Ford-Fulkerson lejon perdorimin e kapaciteteve negative.",
                options: ["PO", "JO"],
                correct: [1],
            },
            {
                question: "Vlera e min cut eshte e njejte me vleren e max flow ne nje sistem.",
                options: ["PO", "JO"],
                correct: [0],
            },
            {
                question: "Topological order nuk mund te gjendet ne rast se ka cikel ne graf.",
                options: ["PO", "JO"],
                correct: [0],
            },
            {
                question: "Brute Force jo gjithmone gjen rezultatet e duhura.",
                options: ["PO", "JO"],
                correct: [0],
            },
            {
                question: "Longest path gjen zbatim ne gjetjen e destinacionit ne navigacion.",
                options: ["PO", "JO"],
                correct: [0],
            },
            {
                question: "Key-Index-Counting merr kohe lineare proporcionale me Radix.",
                options: ["PO", "JO"],
                correct: [0],
            },
            {
                question: "LSD algoritmi shpenzon me shume hapesire gjate ekzekutimit se MSD.",
                options: ["PO", "JO"],
                correct: [1],
            },
            {
                question: "NFA te Regular Expressions implementon Queues gjate implementimit te makinerise.",
                options: ["PO", "JO"],
                correct: [1],
            },
            {
                question: "Kompleksiteti kohor per Algoritmin Dijkstra (SP) eshte linear.",
                options: ["PO", "JO"],
                correct: [1],
            },
            {
                question: "Kur kemi te bejme me rehashing te çelesave:",
                options: ["Mund te ndryshoje vlera e hash(x) funksionimit", "Mund te ndryshoje vetem çelesi", "Hashcode nuk ndryshon kurre", "Vetem per klasat primitive ndodh"],
                correct: [0],
            },
            {
                question: "Resizing tek hash-tabela behet kur kemi te bejme me:",
                options: ["Kur shtojme nje vlere me gjatesi te madhe", "Kur ka shume kolizione", "Zenie me shume se ½ te entries", "Kur lista e çelesave tejkalon numrin e kulmeve"],
                correct: [2],
            },
            {
                question: "Strategjite per ballafaqim me kolizionet te cilat perdorin open addressing jane:",
                options: ["Quadratic hashing", "Double hashing", "Linear hashing", "Separate Chaining"],
                correct: [1, 2],
            },
            {
                question: "Ne çdo block BST definohet sakte qe:",
                options: ["Mund te kete lidhes te shumte me rrenjen", "Subtree nuk ka dy lidhes te huaj - i lidhur ne seri", "Mund te jete pa nyje femije", "Ka lidhje ciklike per pershpejtim te kerkimit"],
                correct: [1],
            },
            {
                question: "Per çdo x dhe y, ç'jane requirement per ta plotesuar rroten simetrike ne relacione Java:",
                options: ["x.equals(y) = true dhe y.equals(x) = false", "x.equals(x) = false", "x.equals(x) = true dhe x.equals(y) nese y.equals(x)", "x.hashCode() = y.hashCode()"],
                correct: [2],
            },
            {
                question: "Algoritmet me kompleksitet N² (worst case) jane:",
                options: ["Insertion Sort", "Shell Sort", "Quick Sort", "Merge Sort"],
                correct: [0, 1],
            },
            {
                question: "Stresi qe kemi kur kemi konstant per insert dhe search:",
                options: ["Mundesine e krijimit te tompujeve lineare", "Shpejtesine e hashing te pabarabarte", "Rritjen e madhesise se memorie", "Mundesine e kalimit nga 2 modes ne 3 modes dhe anasjelltas"],
                correct: [0, 3],
            },
            {
                question: "Linked listat:",
                options: ["Implementojne lloj te te dhenave abstrakte", "Jane statike dhe fikse", "Jane struktura te te dhenave dinamike", "Nuk mbeshtesin fshirjen e nyjeve"],
                correct: [0, 2],
            },
            {
                question: "Atributet ne baze te te cilave analizohen efikasiteti i algoritmeve:",
                options: ["Big O(n)", "Hapat kohore", "Hapesira memoruese", "Numri i pointereve"],
                correct: [0, 1, 2],
            },
            {
                question: "Tipa immutable te te dhenave jane:",
                options: ["String", "ArrayList", "Object", "Color"],
                correct: [0, 3],
            },
            {
                question: "Strategjite per ballafaqimin me kolizionet tek hash tables:",
                options: ["Double Chaining", "Hash Splitting", "Linear Probing", "Separate Hashing"],
                correct: [0, 2, 3],
            },
            {
                question: "Metodat qe gjenden ne API Symbol Tables Java:",
                options: ["put(key)", "size()", "contains(key)", "merge()"],
                correct: [0, 1, 2],
            },
            {
                question: "Ne nje BST teknika per te fshire qe njihet si lazy approach:",
                options: ["Memory overload", "Kom. kohor kalon nga logaritmik ne linear", "Mund te fshije vetem rrenjen", "Nuk eshte e lejuar per balanced trees"],
                correct: [1],
            },
            {
                question: "Metodat per futjen e elementeve tek Stack dhe Queue jane:",
                options: ["pop()", "enqueue()", "delete()", "push()"],
                correct: [1, 3],
            },
            {
                question: "Oper. kryesore qe perdoren tek Priority Queues jane:",
                options: ["delMax()", "insert()", "enqueue()", "size()"],
                correct: [0, 1],
            },
            {
                question: "Disa nga oper. ne BST jane:",
                options: ["floor", "rank", "get", "put"],
                correct: [0, 1, 2, 3],
            },
            {
                question: "Tipa abstrakte te te dhenave:",
                options: ["Bags", "Queues and Stacks", "ArrayList", "Hash Table"],
                correct: [0, 1, 3],
            }
        ];

        // ---------------------------------------------------

        // State
        let current = 0;
        const answered = new Array(questions.length).fill(false); // true if user satisfied (selected correct or used show)
        const shown = new Array(questions.length).fill(false); // if user used show answers

        // DOM refs
        const qList = document.getElementById('questionList');
        const questionText = document.getElementById('questionText');
        const optionsDiv = document.getElementById('options');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const showBtn = document.getElementById('showBtn');
        const statusText = document.getElementById('statusText');
        const hint = document.getElementById('hint');
        const progress = document.getElementById('progress');

        function renderQuestionList() {
            qList.innerHTML = '';
            questions.forEach((q, i) => {
                const btn = document.createElement('button');
                btn.className = 'qbtn' + (i === current ? ' active' : '');
                btn.textContent = `#${i + 1} ${answered[i] ? '(done)' : ''}`;
                btn.addEventListener('click', () => { selectQuestion(i); });
                qList.appendChild(btn);
            });
            updateProgress();
        }

        function updateProgress() {
            const done = answered.filter(Boolean).length;
            progress.textContent = `${done}/${questions.length}`;
        }

        function selectQuestion(index) {
            current = index;
            renderQuestionList();
            showQuestion();
        }

        function showQuestion() {
            const q = questions[current];
            questionText.textContent = `(${current + 1}) ` + q.question;
            optionsDiv.innerHTML = '';
            hint.textContent = '';

            // Create checkbox/radio depending on whether multiple correct answers
            const multiple = q.correct.length > 1;

            q.options.forEach((opt, idx) => {
                const id = `opt-${current}-${idx}`;
                const label = document.createElement('label');
                label.className = 'option';
                label.setAttribute('data-idx', idx);

                const input = document.createElement('input');
                input.type = multiple ? 'checkbox' : 'radio';
                input.name = 'opt-' + current;
                input.value = idx;
                input.id = id;
                input.addEventListener('change', onAnswerChange);

                const span = document.createElement('span');
                span.textContent = opt;

                label.appendChild(input);
                label.appendChild(span);
                optionsDiv.appendChild(label);
            });

            // If previously used Show, reveal
            if (shown[current]) revealAnswers();

            updateNavigationState();
        }

        function getSelectedIndices() {
            const inputs = optionsDiv.querySelectorAll('input');
            const sel = [];
            inputs.forEach(i => { if (i.checked) sel.push(Number(i.value)); });
            sel.sort((a, b) => a - b);
            return sel;
        }

        function arraysEqual(a, b) {
            if (a.length !== b.length) return false;
            for (let i = 0; i < a.length; i++) if (a[i] !== b[i]) return false;
            return true;
        }

        function onAnswerChange() {
            const q = questions[current];
            const sel = getSelectedIndices();

            // No auto‑show answers, no marking as correct/incorrect visually
            if (arraysEqual(sel, q.correct.slice().sort((a, b) => a - b))) {
                statusText.textContent = 'Saktë — mund të kalosh.';
                statusText.style.color = '#0a7f35';
                answered[current] = true;
            } else {
                statusText.textContent = 'Gabim — provo prap.';
                statusText.style.color = '#b33';
                answered[current] = false;
            }
            updateProgress();
            updateNavigationState();
        }

        function revealAnswers() {
            const q = questions[current];
            const inputs = optionsDiv.querySelectorAll('input');
            inputs.forEach(i => {
                const idx = Number(i.value);
                i.checked = q.correct.includes(idx);
            });
            shown[current] = true;
            answered[current] = true;
            statusText.textContent = 'Përgjigjet u shfaqën. Mund të kalosh.';
            statusText.style.color = '#0a7f35';
            updateProgress();
            updateNavigationState();
        }
        /*(){
              const q = questions[current];
              const inputs = optionsDiv.querySelectorAll('input');
              inputs.forEach(i=>{
                const idx = Number(i.value);
                i.checked = q.correct.includes(idx);
              });
              shown[current] = true;
              answered[current] = true; // allow progress
              statusText.textContent = 'Përgjigjet u shfaqën. Mund të kalosh.';
              statusText.style.color = '#0a7f35';
              updateProgress();
              markOptionsCorrectness();
              updateNavigationState();
            }*/

        function updateNavigationState() {
            prevBtn.disabled = current === 0 ? true : false;
            // Next disabled unless this question is answered
            nextBtn.disabled = !answered[current];
        }

        prevBtn.addEventListener('click', () => {
            if (current > 0) selectQuestion(current - 1);
        });

        nextBtn.addEventListener('click', () => {
            if (!answered[current]) {
                hint.textContent = 'Duhet të zgjedhësh përgjigjet e sakta ose të përdorësh "Show answers".';
                return;
            }
            if (current < questions.length - 1) selectQuestion(current + 1);
            else alert('Mbarove pyetjet. Progres: ' + answered.filter(Boolean).length + '/' + questions.length);
        });

        showBtn.addEventListener('click', () => {
            if (confirm('Tregon përgjigjet e sakta për këtë pyetje? (Do të lejojë të kalosh)')) {
                revealAnswers();
            }
        });

        // Init
        renderQuestionList();
        selectQuestion(0);

    </script>

</body>

</html>